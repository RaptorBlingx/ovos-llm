"""
Hybrid Intent Parser for ENMS OVOS Skill
========================================

Multi-tier adaptive routing:
- Tier 1 (Heuristic): Ultra-fast regex patterns (<5ms)
- Tier 2 (Adapt): Fast pattern matching (<10ms) [future]
- Tier 3 (LLM): Complex NLU with Qwen3 (300-500ms)

Goal: Route 80% of queries via Tier 1+2 (<10ms) for <200ms P50 latency
"""

import re
import time
from typing import Dict, Optional, List, Tuple
from enum import Enum

import structlog

from .models import Intent, IntentType
from .adapt_parser import AdaptParser
from .time_parser import TimeRangeParser
from .observability import (
    tier_routing,
    query_latency,
    queries_total,
    active_queries
)

logger = structlog.get_logger()


class RoutingTier(str, Enum):
    """Which parser tier handled the query"""
    HEURISTIC = "heuristic"
    ADAPT = "adapt"
    LLM = "llm"


class HeuristicRouter:
    """
    Tier 1: Ultra-fast regex-based intent detection
    
    Handles:
    - "top N" queries → ranking
    - "top N machines" → ranking
    - "factory overview" → factory_overview
    - "factory status" → factory_overview
    - "total kwh" → factory_overview
    - "{machine} status" → machine_status
    - "{machine} power" → power_query
    - "{machine} kwh" → energy_query
    - "{machine} energy" → energy_query
    - "compare {machine1} and {machine2}" → comparison
    """
    
    # Known machine names (loaded from validator)
    MACHINES = [
        "Boiler-1", "Compressor-1", "Compressor-EU-1", "Conveyor-A",
        "HVAC-EU-North", "HVAC-Main", "Injection-Molding-1", "Turbine-1"
    ]
    
    # Regex patterns (compiled for speed)
    # CRITICAL: Order matters! More specific patterns first
    PATTERNS = {
        # NEW: Production queries (units, quality, OEE)
        'production': [
            re.compile(r'\bhow\s+many\s+units', re.IGNORECASE),
            re.compile(r'\bunits?\s+(?:produced|made|manufactured)', re.IGNORECASE),
            re.compile(r'\bproduction\s+(?:count|total|volume)', re.IGNORECASE),
            re.compile(r'\bquality\s+(?:rate|percent|percentage)', re.IGNORECASE),
            re.compile(r'\bOEE\b', re.IGNORECASE),
            re.compile(r'\boverall\s+equipment\s+effectiveness', re.IGNORECASE),
        ],
        
        # Anomaly detection
        'anomaly_detection': [
            re.compile(r'\b(?:show|list|get|display).*?anomal(?:y|ies)', re.IGNORECASE),
            re.compile(r'\banomal(?:y|ies).*?(?:show|list|get)', re.IGNORECASE),
            re.compile(r'\bactive\s+(?:anomal(?:y|ies)|alerts?)', re.IGNORECASE),
            re.compile(r'\b(?:critical|warning|info)\s+anomal(?:y|ies)', re.IGNORECASE),
            re.compile(r'\bcheck\s+for\s+anomal(?:y|ies)', re.IGNORECASE),
            re.compile(r'\bdetect\s+anomal(?:y|ies)', re.IGNORECASE),
            re.compile(r'\b(?:any|are there)\s+anomal(?:y|ies)', re.IGNORECASE),
            # NEW: Which machines have anomalies
            re.compile(r'\b(?:which|what).*?machines?.*?(?:anomal|alert|issue|problem)', re.IGNORECASE),
            re.compile(r'\bmachines?.*?(?:have|with|has).*?(?:anomal|alert)', re.IGNORECASE),
        ],
        
        # NEW: Baseline prediction (expected/predicted energy)
        'baseline_models': [
            re.compile(r'\b(?:list|show|get).*?baseline\s+models?', re.IGNORECASE),
            re.compile(r'\bbaseline\s+models?\s+(?:for|exist|available)', re.IGNORECASE),
            re.compile(r'\bwhat\s+baseline\s+models?', re.IGNORECASE),
            re.compile(r'\bhistory\s+of.*?baseline\s+models?', re.IGNORECASE),
        ],
        
        # NEW: Forecast (future prediction) - MUST come before KPI to catch temporal queries
        'forecast': [
            re.compile(r'\b(?:when|what\s+time).*?(?:peak|demand).*?(?:tomorrow|next|tonight)', re.IGNORECASE),
            re.compile(r'\b(?:forecast|tomorrow|tonight|next\s+(?:day|week|month))', re.IGNORECASE),
            re.compile(r'\bwhat.*?(?:will|going\s+to)\s+(?:consume|use)', re.IGNORECASE),
            re.compile(r'\bhow\s+much.*?(?:tomorrow|next\s+(?:day|week))', re.IGNORECASE),
        ],
        
        'kpi': [
            re.compile(r'\bKPIs?\b', re.IGNORECASE),
            re.compile(r'\bkey\s+performance\s+indicators?', re.IGNORECASE),
            re.compile(r'\b(?:show|get|what).*?KPIs?\b', re.IGNORECASE),
            re.compile(r'\b(?:energy\s+efficiency|load\s+factor|peak\s+demand|carbon\s+intensity)', re.IGNORECASE),
            re.compile(r'\bspecific\s+energy\s+consumption', re.IGNORECASE),
            # Standalone "efficiency" queries (SEC, load factor, efficiency score)
            re.compile(r'\b(?:what|show|get).*?efficiency', re.IGNORECASE),
            re.compile(r'\befficiency.*?(?:of|for)', re.IGNORECASE),
        ],
        
        'performance': [
            re.compile(r'\banalyze\s+performance', re.IGNORECASE),
            re.compile(r'\banalyze\s+\w+.*?performance', re.IGNORECASE),
            re.compile(r'\bperformance\s+(?:analysis|of|for)', re.IGNORECASE),
            re.compile(r'\b(?:efficiency|performance)\s+(?:score|rating|status)', re.IGNORECASE),
            re.compile(r'\bhow.*?performing', re.IGNORECASE),
            re.compile(r'\broot\s+cause', re.IGNORECASE),
        ],
        
        'baseline': [
            re.compile(r'\b(?:expected|predicted)\s+(?:energy|power|consumption)', re.IGNORECASE),
            re.compile(r'\bpredict.*?(?:energy|power|consumption)', re.IGNORECASE),
            re.compile(r'\bbaseline\s+prediction', re.IGNORECASE),
            re.compile(r'\bbaseline\s+for\s+({})'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            re.compile(r'\b(?:what|get|give|show).*?baseline\s+(?:for|of)', re.IGNORECASE),
            re.compile(r'\benergy\s+(?:with|at)\s+(?:temp|temperature|pressure|load)', re.IGNORECASE),
        ],
        
        # Baseline models (list models for a machine)
        'baseline_models': [
            re.compile(r'\blist.*?baseline.*?models?', re.IGNORECASE),
            re.compile(r'\bbaseline.*?models?.*?(?:for|of)', re.IGNORECASE),
            re.compile(r'\b(?:does|do|has|have).*?baseline.*?model', re.IGNORECASE),
            re.compile(r'\bhow\s+many.*?baseline.*?models?', re.IGNORECASE),
            re.compile(r'\bshow.*?baseline.*?models?', re.IGNORECASE),
        ],
        
        # Baseline explanation (key drivers, model accuracy)
        'baseline_explanation': [
            re.compile(r'\bkey\s+energy\s+drivers?', re.IGNORECASE),
            re.compile(r'\bexplain.*?(?:baseline|model)', re.IGNORECASE),
            re.compile(r'\bhow\s+accurate.*?(?:model|baseline)', re.IGNORECASE),
            re.compile(r'\btell\s+me\s+about.*?(?:baseline|model)', re.IGNORECASE),
            re.compile(r'\bwhat\s+(?:drives?|affects?|impacts?).*?energy', re.IGNORECASE),
            re.compile(r'\bmodel\s+(?:details?|info|explanation)', re.IGNORECASE),
        ],
        
        # NEW: SEUs - Significant Energy Uses (case insensitive: seu, seus, SEU, SEUs)
        'seus': [
            re.compile(r'\bseus?\b', re.IGNORECASE),  # seu, seus, SEU, SEUs
            re.compile(r'\bsignificant\s+energy\s+uses?\b', re.IGNORECASE),
            re.compile(r'\benergy\s+uses?\b', re.IGNORECASE),
            re.compile(r'\blist.*?(?:all\s+)?(?:available\s+)?seus?\b', re.IGNORECASE),
            re.compile(r'\b(?:show|get|what).*?seus?\b', re.IGNORECASE),
            re.compile(r'\bwhich\s+seus?\b', re.IGNORECASE),
            re.compile(r'\belectricity\s+seus?\b', re.IGNORECASE),
            re.compile(r'\bnatural\s+gas\s+seus?\b', re.IGNORECASE),
            re.compile(r'\bsteam\s+seus?\b', re.IGNORECASE),
            # SEU baseline queries
            re.compile(r'\bwhich\s+seu.*?(?:have|has|with|without).*?baselines?', re.IGNORECASE),
            re.compile(r'\bseu.*?(?:don\'t|do not|doesn\'t|does not|no|without).*?baselines?', re.IGNORECASE),
            re.compile(r'\bseu.*?(?:need|require|missing).*?baselines?', re.IGNORECASE),
        ],
        
        # Top N ranking queries (CRITICAL: handle "top 3", "top 5 machines", etc.)
        'ranking': [
            re.compile(r'\btop\s+(\d+)\s*(?:machines?|consumers?)?\b', re.IGNORECASE),
            re.compile(r'\bshow\s+(?:me\s+)?(?:the\s+)?top\s+(\d+)', re.IGNORECASE),
            re.compile(r'\b(\d+)\s+top\s+(?:machines?|consumers?)', re.IGNORECASE),
            # NEW: "top consumers/machines" without number
            re.compile(r'\btop\s+(?:energy\s+)?consumers?\b', re.IGNORECASE),
            re.compile(r'\btop\s+(?:energy\s+)?(?:consuming\s+)?machines?\b', re.IGNORECASE),
            # NEW: Efficiency/cost ranking (which machine = ranking, not machine extraction)
            re.compile(r'\brank.*?by\s+(?:efficiency|cost)', re.IGNORECASE),
            re.compile(r'\bwhich\s+machine.*?most\s+(?:efficient|cost-effective)', re.IGNORECASE),
            re.compile(r'\bwhich\s+machine.*?(?:uses?|consumes?)\s+(?:the\s+)?most', re.IGNORECASE),
            re.compile(r'\bwhich\s+machine.*?(?:has|have)\s+(?:the\s+)?most\s+alerts', re.IGNORECASE),
            # NEW: Cost-based ranking
            re.compile(r'\bwhich\s+machine.*?cost.*?(?:most|highest)', re.IGNORECASE),
            re.compile(r'\bwhich\s+machine.*?(?:most|highest).*?cost', re.IGNORECASE),
            re.compile(r'\bcost.*?(?:most|highest).*?(?:machine|run)', re.IGNORECASE),
            re.compile(r'\bmost\s+expensive\s+(?:machine|to\s+run)', re.IGNORECASE),
            # NEW: Least/lowest ranking
            re.compile(r'\bwhich\s+machine.*?(?:uses?|consumes?)\s+(?:the\s+)?least', re.IGNORECASE),
            re.compile(r'\bwhich\s+machine.*?(?:lowest|minimum)', re.IGNORECASE),
            re.compile(r'\bcheapest\s+(?:machine|to\s+run)', re.IGNORECASE),
            # NEW: Which/what {type} units/machines - STAYS in ranking for filtered search
            re.compile(r'\b(?:which|what)\s+(HVAC|Boiler|Compressor|Conveyor|Turbine|Hydraulic|Injection)\s+(?:units?|machines?)', re.IGNORECASE),
            re.compile(r'\bfind.*?(HVAC|Boiler|Compressor|Conveyor|Turbine|Hydraulic|Injection)', re.IGNORECASE),
            # NEW: How many {type} machines - STAYS in ranking for filtered search
            re.compile(r'\bhow\s+many\s+(HVAC|Boiler|Compressor|Conveyor|Turbine|Hydraulic|Injection)', re.IGNORECASE),
        ],
        
        # Factory-wide queries
        'factory_overview': [
            re.compile(r'\bfactory\s+(?:overview|status|summary)\b', re.IGNORECASE),
            re.compile(r'\btotal\s+(?:factory\s+)?(?:kwh|consumption|energy|power)\b', re.IGNORECASE),
            re.compile(r'\b(?:complete|full)\s+factory\b', re.IGNORECASE),
            re.compile(r'\bfacility\s+(?:overview|status)\b', re.IGNORECASE),
            # Machine listing - calls GET /machines
            re.compile(r'\blist\s+(?:all\s+)?machines', re.IGNORECASE),
            re.compile(r'\bshow\s+(?:me\s+)?(?:all\s+)?machines', re.IGNORECASE),
            re.compile(r'\bwhat\s+machines\s+(?:do\s+we\s+have|are\s+there)', re.IGNORECASE),
            # NEW: Carbon/emissions queries
            re.compile(r'\bcarbon\s+(?:footprint|emissions?)\b', re.IGNORECASE),
            re.compile(r'\b(?:what|how\s+much).*?carbon\b', re.IGNORECASE),
            re.compile(r'\bCO2\s+emissions?\b', re.IGNORECASE),
            re.compile(r'\bemissions?\s+(?:total|today)\b', re.IGNORECASE),
            # NEW: Cost queries (factory-wide aggregate)
            re.compile(r'\b(?:how\s+much|what).*?(?:is|are).*?(?:energy|electricity|power)?\s*cost', re.IGNORECASE),
            re.compile(r'\bcost(?:ing|s)?\s+(?:us|today|this\s+month)', re.IGNORECASE),
            re.compile(r'\btotal\s+(?:energy\s+)?cost', re.IGNORECASE),
            re.compile(r'\benergy\s+(?:cost|expense|bill)', re.IGNORECASE),
            re.compile(r'\belectricity\s+(?:cost|bill|expense)', re.IGNORECASE),
            re.compile(r'\bhow\s+much\s+(?:are\s+we|have\s+we)\s+(?:spending|spent)', re.IGNORECASE),
            # NEW: Active/offline machine queries
            re.compile(r'\b(?:show|list|what).*?(?:active|online|running).*?(?:machines?|equipment)', re.IGNORECASE),
            re.compile(r'\b(?:show|list|what).*?(?:inactive|offline|stopped).*?(?:machines?|equipment)', re.IGNORECASE),
            # NEW: Aggregated stats
            re.compile(r'\baggregated?\s+(?:stats?|statistics?)', re.IGNORECASE),
            # NEW: Multi-factory comparison
            re.compile(r'\bcompare.*?(?:across|all)\s+factories', re.IGNORECASE),
            re.compile(r'\bwhich\s+factory', re.IGNORECASE),
            # NEW: Performance engine health
            re.compile(r'\bperformance\s+engine', re.IGNORECASE),
            re.compile(r'\bengine\s+(?:health|status|running)', re.IGNORECASE),
            # NEW: Energy saving opportunities
            re.compile(r'\bsaving\s+opportunities', re.IGNORECASE),
            re.compile(r'\benergy\s+saving', re.IGNORECASE),
            re.compile(r'\bimprovement\s+opportunities', re.IGNORECASE),
            re.compile(r'\bopportunities', re.IGNORECASE),
            # NEW: ISO 50001 EnPI reports
            re.compile(r'\benpi\s+report', re.IGNORECASE),
            re.compile(r'\benergy\s+performance\s+indicators?', re.IGNORECASE),
            re.compile(r'\biso\s*50001', re.IGNORECASE),
            re.compile(r'\bcompliance\s+report', re.IGNORECASE),
            # NEW: ISO action plans
            re.compile(r'\blist.*?action\s+plans?', re.IGNORECASE),
            re.compile(r'\baction\s+plans?.*?list', re.IGNORECASE),
            re.compile(r'\biso\s+action\s+plans?', re.IGNORECASE),
        ],
        
        # Machine status queries
        'machine_status': [
            re.compile(r'\b({})\s+(?:status|online|offline|running|availability)\b'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            re.compile(r'\b(?:is|check)\s+({})\s*(?:running|online|offline)?\b'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            re.compile(r'\b({})\s+availability\b'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            # NEW: Show/get info/details for machine
            re.compile(r'\b(?:show|get|display)\s+(?:info|details|information)\s+(?:for|about)\s+({})'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            re.compile(r'\b({})(?:\s+info|\s+details|\s+information)\b'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
        ],
        
        # Power queries
        'power_query': [
            re.compile(r'\b({})\s+(?:power|watts?|kw)\b'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            re.compile(r'\bpower\s+(?:of\s+)?({})'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            # Handle short forms like "HVAC watts" (extract HVAC from HVAC-EU-North)
            re.compile(r'\b(HVAC|Boiler|Compressor|Conveyor|Turbine|Injection)[^\s]*\s+(?:power|watts?|kw)\b', re.IGNORECASE),
            # NEW: Steam flow rate (technically power query for steam)
            re.compile(r'\bsteam\s+flow\s+rate', re.IGNORECASE),
        ],
        
        # Energy queries
        'energy_query': [
            re.compile(r'\b({})\s+(?:energy|kwh|consumption)\b'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            re.compile(r'\benergy\s+(?:of\s+)?({})'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            re.compile(r'\b({})\s+(?:used|consumed)'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            # NEW: Multi-energy support (moved from machine_status)
            re.compile(r'\benergy\s+(?:types?|sources?)\s+(?:does|for)\s+({})'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            re.compile(r'\blist.*?energy\s+sources?\s+for\s+({})'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            re.compile(r'\bwhat\s+energy.*?({})'.format('|'.join(re.escape(m) for m in MACHINES)), re.IGNORECASE),
            re.compile(r'\b(?:what|which)\s+energy\s+(?:types?|sources?)', re.IGNORECASE),
            re.compile(r'\benergy\s+types?\s+(?:does|for)', re.IGNORECASE),
            re.compile(r'\benergy\s+summary', re.IGNORECASE),
            re.compile(r'\b(?:natural\s+gas|electricity|steam|compressed\s+air)\s+(?:consumption|usage|readings?)', re.IGNORECASE),
            re.compile(r'\bshow.*?(?:natural\s+gas|steam|electricity|compressed\s+air)', re.IGNORECASE),
            # NEW: Energy breakdown
            re.compile(r'\benergy\s+breakdown', re.IGNORECASE),
            re.compile(r'\bsummarize.*?energy.*?consumption', re.IGNORECASE),
            re.compile(r'\btotal\s+energy\s+usage', re.IGNORECASE),
        ],
        
        # Comparison queries
        'comparison': [
            re.compile(r'\bcompare\s+.*?(?:between\s+)?({}).*?(?:and|vs|versus)\s+({})'.format(
                '|'.join(re.escape(m) for m in MACHINES),
                '|'.join(re.escape(m) for m in MACHINES)
            ), re.IGNORECASE),
            re.compile(r'\b({})\s+vs\s+({})'.format(
                '|'.join(re.escape(m) for m in MACHINES),
                '|'.join(re.escape(m) for m in MACHINES)
            ), re.IGNORECASE),
            # NEW: Performance comparison (with fuzzy extraction fallback)
            re.compile(r'\bcompare.*?performance', re.IGNORECASE),
            # NEW: General comparison without specific machine names
            re.compile(r'\bcompare\s+(?:the\s+)?(.+?)\s+(?:and|vs|versus)\s+(.+?)(?:\s+performance)?$', re.IGNORECASE),
        ],
        
        # Report generation (PDF reports) - comprehensive patterns
        'report': [
            # === GENERATE/CREATE patterns ===
            re.compile(r'\b(?:generate|create|make|produce|build|prepare)\s+(?:a\s+)?(?:the\s+)?(?:monthly\s+)?(?:energy\s+)?(?:enpi\s+)?report', re.IGNORECASE),
            re.compile(r'\b(?:generate|create|make|produce)\s+(?:a\s+)?(?:the\s+)?(?:enpi\s+)?pdf', re.IGNORECASE),
            re.compile(r'\breport\s+(?:generation|creation)', re.IGNORECASE),
            
            # === MONTH-SPECIFIC patterns ===
            re.compile(r'\breport\s+(?:for|of)\s+(?:january|february|march|april|may|june|july|august|september|october|november|december)', re.IGNORECASE),
            re.compile(r'\b(?:january|february|march|april|may|june|july|august|september|october|november|december)\s+(?:\d{4}\s+)?report', re.IGNORECASE),
            re.compile(r'\b(?:january|february|march|april|may|june|july|august|september|october|november|december)(?:\'?s)?\s+(?:energy\s+)?(?:enpi\s+)?report', re.IGNORECASE),
            re.compile(r'\breport\s+for\s+(?:january|february|march|april|may|june|july|august|september|october|november|december)\s+\d{4}', re.IGNORECASE),
            
            # === RELATIVE TIME patterns ===
            re.compile(r'\b(?:last|this|previous|current)\s+month(?:\'?s)?\s+report', re.IGNORECASE),
            re.compile(r'\breport\s+for\s+(?:last|this|previous)\s+month', re.IGNORECASE),
            re.compile(r'\bmonthly\s+(?:energy\s+)?(?:performance\s+)?report', re.IGNORECASE),
            re.compile(r'\bmonth(?:\'?s)?\s+energy\s+report', re.IGNORECASE),
            
            # === ENPI-SPECIFIC patterns ===
            re.compile(r'\benpi\s+(?:pdf\s+)?report', re.IGNORECASE),
            re.compile(r'\benergy\s+performance\s+(?:indicator\s+)?report', re.IGNORECASE),
            re.compile(r'\biso\s*50001\s+report', re.IGNORECASE),
            re.compile(r'\bperformance\s+report\s+pdf', re.IGNORECASE),
            
            # === DOWNLOAD/GET patterns ===
            re.compile(r'\bdownload\s+(?:the\s+)?(?:monthly\s+)?(?:enpi\s+)?report', re.IGNORECASE),
            re.compile(r'\bdownload\s+(?:the\s+)?pdf', re.IGNORECASE),
            re.compile(r'\bget\s+(?:me\s+)?(?:a\s+)?(?:the\s+)?(?:monthly\s+)?(?:enpi\s+)?report', re.IGNORECASE),
            re.compile(r'\bgive\s+me\s+(?:a\s+)?(?:the\s+)?(?:energy\s+)?(?:enpi\s+)?report', re.IGNORECASE),
            re.compile(r'\bi\s+(?:need|want)\s+(?:a\s+)?(?:the\s+)?(?:monthly\s+)?report', re.IGNORECASE),
            re.compile(r'\bcan\s+(?:you\s+)?(?:generate|create|get|give)\s+(?:me\s+)?(?:a\s+)?report', re.IGNORECASE),
            re.compile(r'\bpull\s+(?:the\s+)?(?:monthly\s+)?report', re.IGNORECASE),
            re.compile(r'\bexport\s+(?:the\s+)?(?:energy\s+)?report', re.IGNORECASE),
            re.compile(r'\bsend\s+(?:me\s+)?(?:the\s+)?report', re.IGNORECASE),
            
            # === LIST/AVAILABLE patterns ===
            re.compile(r'\b(?:what|which)\s+reports?\s+(?:can|are|do|types?)', re.IGNORECASE),
            re.compile(r'\blist\s+(?:all\s+)?(?:available\s+)?reports?', re.IGNORECASE),
            re.compile(r'\bavailable\s+reports?', re.IGNORECASE),
            re.compile(r'\breport\s+types?', re.IGNORECASE),
            re.compile(r'\bwhat\s+(?:kind|type)\s+of\s+reports?', re.IGNORECASE),
            re.compile(r'\bshow\s+(?:me\s+)?(?:available\s+)?reports?', re.IGNORECASE),
            
            # === PREVIEW patterns ===
            re.compile(r'\bpreview\s+(?:the\s+)?(?:monthly\s+)?report', re.IGNORECASE),
            re.compile(r'\bshow\s+(?:me\s+)?report\s+(?:data|preview|summary)', re.IGNORECASE),
            re.compile(r'\breport\s+preview', re.IGNORECASE),
            
            # === SIMPLE/SHORT patterns ===
            re.compile(r'^(?:the\s+)?report(?:\s+please)?$', re.IGNORECASE),
            re.compile(r'^pdf\s+report$', re.IGNORECASE),
            re.compile(r'^energy\s+report$', re.IGNORECASE),
            re.compile(r'^monthly\s+report$', re.IGNORECASE),
            re.compile(r'^enpi\s+report$', re.IGNORECASE),
        ],
    }
    
    def __init__(self):
        """Initialize heuristic router"""
        self.logger = logger.bind(component="heuristic_router")
    
    def _extract_machine_fuzzy(self, utterance: str) -> Optional[str]:
        """
        Extract machine name with fuzzy matching
        
        Handles:
        - Exact: "Compressor-1" → "Compressor-1"
        - Spaced: "compressor 1" → "Compressor-1"  
        - Partial: "compressor" (ambiguous) → "compressor" (validator clarifies)
        - Type: "hvac main" → "HVAC-Main"
        
        Args:
            utterance: User query
            
        Returns:
            Matched machine name or type marker if ambiguous
        """
        utterance_lower = utterance.lower()
        
        # Number words to digits mapping
        number_words = {
            'one': '1', 'two': '2', 'three': '3', 'four': '4', 'five': '5',
            'six': '6', 'seven': '7', 'eight': '8', 'nine': '9', 'ten': '10'
        }
        
        # Normalize utterance: convert number words to digits
        utterance_normalized = utterance_lower
        for word, digit in number_words.items():
            utterance_normalized = re.sub(rf'\b{word}\b', digit, utterance_normalized)
        
        # Try exact match first (full machine name in query)
        for m in self.MACHINES:
            if m.lower() in utterance_lower:
                return m
        
        # Try "type + number" patterns (e.g., "compressor 1" → "Compressor-1", "compressor one" → "Compressor-1")
        # This handles spoken queries where users say "compressor one" → transcribed as "compressor 1"
        number_patterns = [
            (r'compressor\s*1\b', 'Compressor-1'),
            (r'compressor\s*eu\s*1\b', 'Compressor-EU-1'),
            (r'hvac\s*main\b', 'HVAC-Main'),
            (r'hvac\s*eu\s*north\b', 'HVAC-EU-North'),
            (r'boiler\s*1\b', 'Boiler-1'),
            (r'conveyor\s*a\b', 'Conveyor-A'),
            (r'hydraulic\s*pump\s*1\b', 'Hydraulic-Pump-1'),
            (r'injection\s*molding\s*1\b', 'Injection-Molding-1'),
            (r'turbine\s*1\b', 'Turbine-1'),
        ]
        
        # Check patterns against normalized utterance
        for pattern, machine in number_patterns:
            if re.search(pattern, utterance_normalized):
                if machine in self.MACHINES:
                    return machine
        
        # Try partial match (machine type without suffix)
        # E.g., "hvac" should match "HVAC-Main", "HVAC-EU-North"
        machine_types = {
            'hvac': ['HVAC-Main', 'HVAC-EU-North'],
            'compressor': ['Compressor-1', 'Compressor-EU-1'],
            'boiler': ['Boiler-1'],
            'conveyor': ['Conveyor-A'],
            'pump': ['Hydraulic-Pump-1'],
            'injection': ['Injection-Molding-1'],
            'turbine': ['Turbine-1'],
        }
        
        for machine_type, machines in machine_types.items():
            if machine_type in utterance_lower:
                # Find all matches in whitelist
                matches = [m for m in machines if m in self.MACHINES]
                if matches:
                    # Return special marker for validator to detect ambiguity
                    # Use machine type as placeholder (e.g., "hvac")
                    if len(matches) > 1:
                        return machine_type  # Validator will detect this is ambiguous
                    return matches[0]
        
        return None
    
    def _extract_multiple_machines(self, utterance: str) -> List[str]:
        """
        Extract multiple machine names from utterance for comparison queries
        
        Handles:
        - "Compare Compressor one and HVAC-Main" → ["Compressor-1", "HVAC-Main"]
        - "compressor 1 vs boiler 1" → ["Compressor-1", "Boiler-1"]
        
        Args:
            utterance: User query
            
        Returns:
            List of machine names (normalized)
        """
        utterance_lower = utterance.lower()
        
        # Number words to digits mapping
        number_words = {
            'one': '1', 'two': '2', 'three': '3', 'four': '4', 'five': '5',
            'six': '6', 'seven': '7', 'eight': '8', 'nine': '9', 'ten': '10'
        }
        
        # Normalize utterance: convert number words to digits
        utterance_normalized = utterance_lower
        for word, digit in number_words.items():
            utterance_normalized = re.sub(rf'\b{word}\b', digit, utterance_normalized)
        
        machines_found = []
        
        # Try "type + number" patterns in order of appearance
        number_patterns = [
            (r'compressor\s*1\b', 'Compressor-1'),
            (r'compressor\s*eu\s*1\b', 'Compressor-EU-1'),
            (r'hvac\s*main\b', 'HVAC-Main'),
            (r'hvac\s*eu\s*north\b', 'HVAC-EU-North'),
            (r'boiler\s*1\b', 'Boiler-1'),
            (r'conveyor\s*a\b', 'Conveyor-A'),
            (r'hydraulic\s*pump\s*1\b', 'Hydraulic-Pump-1'),
            (r'injection\s*molding\s*1\b', 'Injection-Molding-1'),
            (r'turbine\s*1\b', 'Turbine-1'),
        ]
        
        # Find all matches with their positions
        matches_with_pos = []
        for pattern, machine in number_patterns:
            match = re.search(pattern, utterance_normalized)
            if match and machine in self.MACHINES:
                matches_with_pos.append((match.start(), machine))
        
        # Sort by position and extract machines
        matches_with_pos.sort(key=lambda x: x[0])
        machines_found = [m for _, m in matches_with_pos]
        
        # If no pattern matches, try exact machine names
        if not machines_found:
            for m in self.MACHINES:
                if m.lower() in utterance_lower:
                    machines_found.append(m)
        
        return machines_found
    
    def route(self, utterance: str) -> Optional[Dict]:
        """
        Attempt to parse utterance using fast heuristics
        
        Args:
            utterance: User query string
            
        Returns:
            Parsed intent dict or None if no pattern matched
        """
        start_time = time.time()
        
        # Normalize utterance
        normalized = utterance.strip()
        utterance_lower = normalized.lower()
        
        # Special case: ISO queries should use factory_overview, not performance
        # This prevents "ISO performance" from matching performance intent
        iso_query = 'iso' in utterance_lower or 'enpi' in utterance_lower or 'compliance report' in utterance_lower
        
        # Try each pattern category
        for intent_type, patterns in self.PATTERNS.items():
            # Skip performance if this is an ISO query
            if intent_type == 'performance' and iso_query:
                continue
                
            for pattern in patterns:
                match = pattern.search(normalized)
                if match:
                    result = self._build_intent(intent_type, match, normalized)
                    if result:
                        latency_ms = (time.time() - start_time) * 1000
                        self.logger.info(
                            "heuristic_match",
                            intent=intent_type,
                            pattern=pattern.pattern[:50],
                            latency_ms=latency_ms
                        )
                        query_latency.labels(intent_type=intent_type, tier="heuristic").observe(latency_ms / 1000)
                        return result
        
        # No pattern matched
        latency_ms = (time.time() - start_time) * 1000
        self.logger.debug("heuristic_no_match", utterance=normalized, latency_ms=latency_ms)
        return None
    
    def _build_intent(self, intent_type: str, match: re.Match, utterance: str) -> Optional[Dict]:
        """
        Build intent dictionary from regex match
        
        CRITICAL: Returns LLM-compatible format (string intent, flat structure)
        This ensures validator compatibility across all tiers
        """
        try:
            if intent_type == 'ranking':
                # Extract N from "top N" if present
                limit = None
                try:
                    limit = int(match.group(1))
                except (IndexError, ValueError):
                    # Check if this is a machine listing query vs top-N ranking
                    utterance_lower = utterance.lower()
                    
                    # Machine listing patterns: "which HVAC units", "find compressors", "how many", "list machines"
                    is_listing = any([
                        re.search(r'\b(?:which|what)\s+(HVAC|Boiler|Compressor|Conveyor|Turbine|Hydraulic|Injection)', utterance_lower),
                        'find' in utterance_lower and any(t in utterance_lower for t in ['hvac', 'boiler', 'compressor', 'conveyor']),
                        'how many' in utterance_lower,
                        'list' in utterance_lower and 'machine' in utterance_lower,
                    ])
                    
                    # Top-N ranking patterns: "which machine uses most", "which machine has most alerts"
                    is_ranking = any([
                        'most' in utterance_lower,
                        'least' in utterance_lower,
                        'highest' in utterance_lower,
                        'lowest' in utterance_lower,
                    ])
                    
                    if is_listing and not is_ranking:
                        limit = None  # Machine listing query
                    else:
                        limit = 1 if is_ranking else 5  # Top-N ranking (1 for "which uses most", 5 for others)
                
                # Determine ranking metric from query
                metric = 'energy'  # default
                utterance_lower = utterance.lower()
                if 'efficiency' in utterance_lower or 'efficient' in utterance_lower:
                    metric = 'efficiency'
                elif 'cost' in utterance_lower:
                    metric = 'cost'
                elif 'alert' in utterance_lower:
                    metric = 'alerts'
                
                # For machine listing queries, set metric to None
                # BUT: if utterance contains "top" or "consumer", it's ALWAYS ranking (not listing)
                is_listing_final = limit is None or (limit == 1 and not any(word in utterance_lower for word in ['most', 'least', 'highest', 'lowest']))
                is_ranking_query = any(word in utterance_lower for word in ['top', 'consumer', 'rank', 'most', 'least'])
                if is_listing_final and not is_ranking_query and any(word in utterance_lower for word in ['which', 'what', 'find', 'list', 'how many']):
                    metric = None
                
                return {
                    'intent': 'ranking',
                    'confidence': 0.95,
                    'limit': limit,
                    'metric': metric,
                    'ranking_metric': metric  # NEW: explicit ranking metric
                }
            
            elif intent_type == 'baseline_models':
                # List baseline models - requires machine name
                machine = self._extract_machine_fuzzy(utterance)
                
                return {
                    'intent': 'baseline_models',
                    'confidence': 0.95,
                    'machine': machine
                }
            
            elif intent_type == 'baseline_explanation':
                # Explain baseline model (key drivers, accuracy) - requires machine name
                machine = self._extract_machine_fuzzy(utterance)
                
                return {
                    'intent': 'baseline_explanation',
                    'confidence': 0.95,
                    'machine': machine
                }
            
            elif intent_type == 'seus':
                # SEUs - Significant Energy Uses - extract energy source filter
                utterance_lower = utterance.lower()
                energy_source = None
                
                if 'electricity' in utterance_lower or 'electric' in utterance_lower:
                    energy_source = 'electricity'
                elif 'natural gas' in utterance_lower or 'gas' in utterance_lower:
                    energy_source = 'natural_gas'
                elif 'steam' in utterance_lower:
                    energy_source = 'steam'
                elif 'compressed air' in utterance_lower:
                    energy_source = 'compressed_air'
                
                return {
                    'intent': 'seus',
                    'confidence': 0.95,
                    'energy_source': energy_source
                }
            
            elif intent_type == 'kpi':
                # KPI queries - extract machine name (fuzzy match for "compressor 1" → "Compressor-1")
                machine = self._extract_machine_fuzzy(utterance)
                
                return {
                    'intent': 'kpi',
                    'confidence': 0.95,
                    'machine': machine
                }
            
            elif intent_type == 'performance':
                # Performance analysis - extract machine name (fuzzy match for "compressor 1" → "Compressor-1")
                machine = self._extract_machine_fuzzy(utterance)
                
                return {
                    'intent': 'performance',
                    'confidence': 0.95,
                    'machine': machine
                }
            
            elif intent_type == 'baseline':
                # Baseline queries - may or may not have machine name
                machine = self._extract_machine_fuzzy(utterance)
                
                return {
                    'intent': 'baseline',
                    'confidence': 0.95,
                    'machine': machine
                }
            
            elif intent_type == 'production':
                # Production queries - extract machine name (fuzzy match)
                machine = self._extract_machine_fuzzy(utterance)
                
                return {
                    'intent': 'production',
                    'confidence': 0.95,
                    'machine': machine
                }
            
            elif intent_type == 'forecast':
                # Forecast queries - may or may not have machine name (fuzzy match)
                machine = self._extract_machine_fuzzy(utterance)
                
                return {
                    'intent': 'forecast',
                    'confidence': 0.95,
                    'machine': machine
                }
            
            elif intent_type == 'factory_overview':
                # Factory overview - may include machine name for filtering (e.g., opportunities for Compressor-1)
                machine = None
                utterance_lower = utterance.lower()
                for m in self.MACHINES:
                    if m.lower() in utterance_lower:
                        machine = m
                        break
                
                return {
                    'intent': 'factory_overview',
                    'confidence': 0.95,
                    'machine': machine
                }
            
            elif intent_type == 'machine_status':
                # Extract machine name from match
                machine = match.group(1)
                return {
                    'intent': 'machine_status',
                    'confidence': 0.95,
                    'machine': self._normalize_machine_name(machine)
                }
            
            elif intent_type == 'power_query':
                machine = match.group(1)
                # Handle partial machine names (e.g., "HVAC" → "HVAC-EU-North" or "HVAC-Main")
                normalized_machine = self._normalize_machine_name(machine)
                # If exact match failed, try fuzzy matching
                if normalized_machine == machine:
                    # Try prefix matching (HVAC → HVAC-EU-North or HVAC-Main)
                    matches = [m for m in self.MACHINES if m.startswith(machine)]
                    if len(matches) == 1:
                        normalized_machine = matches[0]
                    elif len(matches) > 1:
                        # Ambiguous - will be caught by validator
                        normalized_machine = machine
                
                return {
                    'intent': 'power_query',
                    'confidence': 0.95,
                    'machine': normalized_machine,
                    'metric': 'power'
                }
            
            elif intent_type == 'energy_query':
                # Try to extract machine from capture group, fall back to fuzzy matching
                try:
                    machine = match.group(1)
                    machine = self._normalize_machine_name(machine)
                except (IndexError, AttributeError):
                    # No capture group or match failed - use fuzzy extraction
                    machine = self._extract_machine_fuzzy(utterance)
                
                return {
                    'intent': 'energy_query',
                    'confidence': 0.95,
                    'machine': machine,
                    'metric': 'energy'
                }
            
            elif intent_type == 'comparison':
                try:
                    machine1 = match.group(1)
                    machine2 = match.group(2)
                    machine1 = self._normalize_machine_name(machine1)
                    machine2 = self._normalize_machine_name(machine2)
                except (IndexError, AttributeError):
                    # Pattern without capture groups - extract machines using fuzzy matching
                    machines = self._extract_multiple_machines(utterance)
                    if len(machines) >= 2:
                        machine1, machine2 = machines[0], machines[1]
                    else:
                        # Fallback: return empty to trigger adapt parser
                        return None
                
                # Return comma-separated machines (will be split by validator)
                return {
                    'intent': 'comparison',
                    'confidence': 0.95,
                    'machines': f"{machine1},{machine2}"
                }
            
            elif intent_type == 'anomaly_detection':
                # Anomaly detection - may or may not have machine name
                machine = None
                utterance_lower = utterance.lower()
                for m in self.MACHINES:
                    if m.lower() in utterance_lower:
                        machine = m
                        break
                
                return {
                    'intent': 'anomaly_detection',
                    'confidence': 0.95,
                    'machine': machine
                }
            
            elif intent_type == 'report':
                # Report generation - extract month/year and action type
                utterance_lower = utterance.lower()
                
                # Determine report action: generate, list, or preview
                report_action = 'generate'  # default
                if any(word in utterance_lower for word in ['what', 'which', 'list', 'available', 'types']):
                    report_action = 'list_types'
                elif 'preview' in utterance_lower:
                    report_action = 'preview'
                
                # Extract month from utterance
                month_names = {
                    'january': 1, 'jan': 1, 'february': 2, 'feb': 2,
                    'march': 3, 'mar': 3, 'april': 4, 'apr': 4,
                    'may': 5, 'june': 6, 'jun': 6, 'july': 7, 'jul': 7,
                    'august': 8, 'aug': 8, 'september': 9, 'sep': 9, 'sept': 9,
                    'october': 10, 'oct': 10, 'november': 11, 'nov': 11,
                    'december': 12, 'dec': 12
                }
                
                month = None
                year = None
                
                # Check for month names
                for month_name, month_num in month_names.items():
                    if month_name in utterance_lower:
                        month = month_num
                        break
                
                # Handle relative months
                from datetime import datetime
                now = datetime.now()
                if 'last month' in utterance_lower or 'previous month' in utterance_lower:
                    if now.month == 1:
                        month = 12
                        year = now.year - 1
                    else:
                        month = now.month - 1
                        year = now.year
                elif 'this month' in utterance_lower:
                    month = now.month
                    year = now.year
                
                # Default to current month if no month specified and generating
                if month is None and report_action == 'generate':
                    month = now.month
                
                # Default year to current year
                if year is None:
                    year = now.year
                
                return {
                    'intent': 'report',
                    'confidence': 0.95,
                    'report_action': report_action,
                    'month': month,
                    'year': year
                }
            
            return None
            
        except (IndexError, ValueError) as e:
            self.logger.warning("pattern_extraction_error", error=str(e), pattern=intent_type)
            return None
    
    def _normalize_machine_name(self, name: str) -> str:
        """Normalize machine name to match whitelist format"""
        # Number words to digits mapping for spoken input
        number_words = {
            'one': '1', 'two': '2', 'three': '3', 'four': '4', 'five': '5',
            'six': '6', 'seven': '7', 'eight': '8', 'nine': '9', 'ten': '10',
            'first': '1', 'second': '2', 'third': '3'
        }
        
        # Convert number words to digits (e.g., "compressor one" -> "compressor 1")
        name_lower = name.lower()
        for word, digit in number_words.items():
            name_lower = re.sub(rf'\b{word}\b', digit, name_lower)
        
        # Normalize: replace spaces/underscores with hyphens
        name_normalized = name_lower.replace(' ', '-').replace('_', '-')
        
        for machine in self.MACHINES:
            if machine.lower().replace(' ', '-').replace('_', '-') == name_normalized:
                return machine
        
        # If no exact match, return original (validator will handle fuzzy matching)
        return name


class HybridParser:
    """
    Orchestrates multi-tier intent parsing
    
    Routing Strategy:
    1. Try Heuristic (Tier 1) - <5ms, 70-80% coverage
    2. Try Adapt (Tier 2) - <10ms, 10-15% coverage [FUTURE]
    3. Fallback to LLM (Tier 3) - 300-500ms, 10-15% coverage
    
    Performance Target: P50 < 200ms (weighted average)
    """
    
    def __init__(self):
        """Initialize hybrid parser with all tiers"""
        self.logger = logger.bind(component="hybrid_parser")
        
        # Initialize parsers
        self.heuristic = HeuristicRouter()
        self.adapt = AdaptParser()
        
        # Routing stats
        self.stats = {
            'heuristic': 0,
            'adapt': 0,
            'clarification': 0,
            'total': 0
        }
        
        self.logger.info("hybrid_parser_initialized", tiers=["heuristic", "adapt"])
    
    def parse(self, utterance: str) -> Dict:
        """
        Parse utterance using adaptive routing
        
        Args:
            utterance: User query string
            
        Returns:
            Intent dictionary with routing tier metadata
        """
        start_time = time.time()
        tier_used = None
        result = None
        
        try:
            # Tier 1: Heuristic Router (Ultra-Fast)
            result = self.heuristic.route(utterance)
            if result:
                tier_used = RoutingTier.HEURISTIC
                self.stats['heuristic'] += 1
            
            # Tier 2: Adapt (Fast pattern matching)
            if not result:
                result = self.adapt.parse(utterance)
                
                if result:
                    tier_used = RoutingTier.ADAPT
                    self.stats['adapt'] += 1
            
            # Fallback: Return clarification intent for unmatched queries
            if not result or (result and result.get('confidence', 0) < 0.7):
                self.logger.info("clarification_needed",
                                utterance=utterance,
                                confidence=result.get('confidence', 0) if result else 0)
                tier_used = RoutingTier.HEURISTIC  # Mark as heuristic for stats
                self.stats['clarification'] += 1
                result = {
                    'intent': 'clarification_needed',
                    'confidence': 0.5,
                    'utterance': utterance,
                    'response_suggestion': "I'm not sure what you're asking. Try: 'factory overview', 'top energy consumers', or 'power of Machine-Name'"
                }
            
            # Parse time_range if present (from ANY tier, especially LLM)
            # Check both result['entities'] dict and result['time_range'] string
            time_range_str = None
            
            if result and 'entities' in result:
                entities = result.get('entities', {})
                if isinstance(entities, dict):
                    time_range_str = entities.get('time_range')
            
            # Try to extract time range from utterance if not in entities
            if not time_range_str:
                # Look for common time patterns in utterance
                import re
                
                # "from X to Y" - greedy match
                match = re.search(r'from\s+(.+?)\s+to\s+(.+?)(?:\s+(?:am|pm|for|in|at|$))', utterance.lower())
                if match:
                    # Reconstruct full range
                    time_range_str = f"{match.group(1)} to {match.group(2)}"
                else:
                    # Try other patterns
                    for pattern in [
                        r'in\s+the\s+last\s+(\d+\s+)?(\w+)',  # "in the last hour", "in the last 2 days"
                        r'this\s+(week|month|year)',
                        r'last\s+(week|month|year|\d+\s+(?:hour|day|week)s?)',
                        r'between\s+(.+?)\s+and\s+(.+?)(?:\s|$)',
                        r'(yesterday|today)',
                    ]:
                        match = re.search(pattern, utterance.lower())
                        if match:
                            time_range_str = match.group(0)
                            break
            
            # Parse the time range if found
            if time_range_str:
                start_dt, end_dt = TimeRangeParser.parse(time_range_str)
                
                if start_dt and end_dt:
                    # Ensure entities dict exists
                    if 'entities' not in result:
                        result['entities'] = {}
                    
                    result['entities']['time_range'] = time_range_str
                    result['entities']['start_time'] = start_dt
                    result['entities']['end_time'] = end_dt
                    
                    self.logger.info("time_range_parsed",
                                   raw=time_range_str,
                                   start=start_dt.isoformat(),
                                   end=end_dt.isoformat(),
                                   tier=tier_used)
                else:
                    self.logger.warning("time_range_parse_failed", 
                                      raw=time_range_str,
                                      tier=tier_used)
            
            # Add routing metadata
            result['tier'] = tier_used
            result['routing_latency_ms'] = (time.time() - start_time) * 1000
            
            # Update stats
            self.stats['total'] += 1
            
            # Log routing decision
            self.logger.info(
                "query_routed",
                utterance=utterance[:50],
                tier=tier_used,
                intent=result.get('intent'),
                confidence=result.get('confidence'),
                latency_ms=result['routing_latency_ms']
            )
            
            # Update metrics
            tier_routing.labels(tier=tier_used).inc()
            query_latency.labels(intent_type=result.get('intent'), tier=tier_used).observe(result['routing_latency_ms'] / 1000)
            queries_total.labels(intent_type=result.get('intent'), tier=tier_used, status='success').inc()
            
            return result
            
        except Exception as e:
            self.logger.error("parsing_error", error=str(e), utterance=utterance)
            raise
    
    def get_stats(self) -> Dict:
        """Get routing statistics"""
        total = self.stats['total']
        if total == 0:
            return self.stats
        
        return {
            **self.stats,
            'distribution': {
                'heuristic': f"{(self.stats['heuristic'] / total) * 100:.1f}%",
                'adapt': f"{(self.stats['adapt'] / total) * 100:.1f}%",
                'llm': f"{(self.stats['llm'] / total) * 100:.1f}%",
            }
        }
